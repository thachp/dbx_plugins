#!/usr/bin/env python3
"""
Create GitHub releases for built plugins and upload their artifacts.
"""

from __future__ import annotations

import json
import os
import pathlib
import re
import subprocess
import sys
from collections import defaultdict


def run(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=check, text=True, capture_output=True)


def ensure_release(tag: str, title: str, notes: str, target: str, assets: list[pathlib.Path]) -> None:
    exists = run(["gh", "release", "view", tag], check=False)
    if exists.returncode != 0:
        create_cmd = ["gh", "release", "create", tag, "--title", title, "--notes", notes, "--target", target]
        create_cmd.extend(str(asset) for asset in assets)
        result = run(create_cmd, check=False)
        if result.returncode != 0:
            sys.stderr.write(result.stderr or result.stdout)
            raise SystemExit(result.returncode)
    else:
        upload_cmd = ["gh", "release", "upload", tag, "--clobber"]
        upload_cmd.extend(str(asset) for asset in assets)
        result = run(upload_cmd, check=False)
        if result.returncode != 0:
            sys.stderr.write(result.stderr or result.stdout)
            raise SystemExit(result.returncode)


def main() -> int:
    packages_env = os.environ.get("PACKAGES_JSON")
    if not packages_env:
        print("PACKAGES_JSON not provided; nothing to publish.", file=sys.stderr)
        return 0

    try:
        packages = json.loads(packages_env)
    except json.JSONDecodeError as exc:
        print(f"Failed to parse PACKAGES_JSON: {exc}", file=sys.stderr)
        return 1

    artifact_root = pathlib.Path("publish_artifacts")
    if not artifact_root.exists():
        print(f"No artifacts found at {artifact_root}; nothing to publish.", file=sys.stderr)
        return 0

    artifacts_by_package: dict[str, list[pathlib.Path]] = defaultdict(list)
    versions_by_package: dict[str, str] = {}

    for artifact_path in artifact_root.rglob("*.zip"):
        artifact_dir = artifact_path.parent.name
        parts = artifact_dir.split("__", 2)
        if len(parts) != 3:
            print(f"Skipping artifact with unexpected name '{artifact_dir}'", file=sys.stderr)
            continue
        package, version, target = parts
        artifacts_by_package[package].append(artifact_path)
        versions_by_package.setdefault(package, version)

    repository = os.environ.get("GITHUB_REPOSITORY")
    target_sha = os.environ.get("GITHUB_SHA", "")

    for package in packages:

        package_files = artifacts_by_package.get(package)
        if not package_files:
            print(f"No artifacts for package {package}; skipping release creation.", file=sys.stderr)
            continue
        version = versions_by_package.get(package)
        if not version:
            print(f"Unable to determine version for package {package}; skipping.", file=sys.stderr)
            continue

        package_files.sort()
        tag = f"{package}-v{version}"
        title = f"{package} v{version}"
        notes = f"Automated release for {package} v{version} generated by CI."

        print(f"Publishing release {tag} ({repository}) with assets:")
        for asset in package_files:
            print(f"  - {asset}")

        ensure_release(tag=tag, title=title, notes=notes, target=target_sha, assets=package_files)

    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry
    sys.exit(main())
